---
title: "Planned sampling during the Summer 2018 CCE/CalCurCEAS Survey"
author: "Kevin Stierhoff (SWFSC/Advanced Survey Technologies Group)"
output: html_document
---

```{r LoadLibraries, error=FALSE, message=FALSE, warning=FALSE, echo=F}
# Install and load pacman (library management package)
if (!require("pacman")) install.packages("pacman")

# Install and load required packages from CRAN ---------------------------------
pacman::p_load(tidyverse,swfscMisc,lubridate,sp,rgeos,sp,maptools,
          knitr,geosphere,ggrepel,cowplot,sf,leaflet,leaflet.extras,htmltools,
          RODBC,kableExtra,rnaturalearth,shadowtext,here,mapview,magick)

# Install and load required packages from Github -------------------------------
# surveyR
pacman::p_load_gh("kstierhoff/surveyR")

# Set system time zone to GMT
Sys.setenv(tz = "GMT")
# Define method of table generation (whether kable or xtable) for best formatting
doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')
if (is.null(doc.type)) {doc.type <- "html"}

# Set global knitr chunk options
if (.Platform$OS.type == "unix") {
  # Do not specify Cairo device for MacOS
  knitr::opts_chunk$set(echo = F, warning = F, message = F,
                        fig.align = 'center', out.width = '100%', dev = "png", dpi = 150)
} else {
  knitr::opts_chunk$set(echo = F, warning = F, message = F,
                        fig.align = 'center', out.width = '100%', dev = "png", dpi = 150,
                        dev.args = list(type = "cairo"))
}

# determine global knitr table format
if (doc.type == "latex") {
  knitr.format <- "latex"
} else {
  knitr.format <- "html" 
}

# Select tile to use for Leaflet map
# Some good options include CartoDB.Positron, Stamen.Terrain, Esri.WorldImagery, and Esri.OceanBasemap
# View all here: http://leaflet-extras.github.io/leaflet-providers/preview/index.html
leaflet.tile <- "Esri.OceanBasemap" 
```

```{r Functions}
# Convert points to spatial lines -----------------------------------------
points2line <- function(data, long, lat, id_field = NULL, sort_field = NULL) {
  # Convert to SpatialPointsDataFrame
  coordinates(data) <- c(long, lat)
  # If there is a sort field...
  if (!is.null(sort_field)) {
    if (!is.null(id_field)) {
      data <- data[order(data[[id_field]], data[[sort_field]]), ]
    } else {
      data <- data[order(data[[sort_field]]), ]
    }
  }
  # If there is only one path...
  if (is.null(id_field)) {
    lines <- SpatialLines(list(Lines(list(Line(data)), "id")))
    return(lines)
    # Now, if we have multiple lines...
  } else if (!is.null(id_field)) {
    # Split into a list by ID field
    paths <- sp::split(data, data[[id_field]])
    sp_lines <- SpatialLines(list(Lines(list(Line(paths[[1]])), "line1")))
    # I like for loops, what can I say...
    for (p in 2:length(paths)) {
      id <- paste0("line", as.character(p))
      l <- SpatialLines(list(Lines(list(Line(paths[[p]])), id)))
      sp_lines <- spRbind(sp_lines, l)
    }
    return(sp_lines)
  }
}
```

```{r UserControls}
get.db     <- F
save.figs  <- T
do.spatial <- T
```

```{r GetWaypoints}
wpt     <- read_csv(here("Data/waypoints_all.csv"))
uctd    <- read_csv(here("Data/waypoints_uctd.csv")) 
calcofi <- read_csv(here("Data/calcofi_stations_all.csv"))  
```

```{r LoadShapefiles,include=F}
# Get CA State Waters shapefile
ca_waters <- st_read(here("GIS/MAN_CA_StateWater.shp")) %>% 
  st_transform(4326)

# CA MPAs
ca_mpas <- st_read(here("GIS/MPA_CA_Existing.shp")) %>% 
  st_transform(4326) %>% 
  mutate(MPA = paste(NAME, Type))
```

```{r ConvertToSpatial}
# Get transect points
tx.c <- filter(wpt, Type == "Compulsory")
tx.a <- filter(wpt, Type == "Adaptive")
tx.s <- filter(wpt, Type == "Saildrone")
tx.m <- filter(wpt, Type == "Mammal")
tx.t <- filter(wpt, Type == "Transit")
tx.80 <- calcofi %>% 
  filter(line == 80, corestation == TRUE)

# Create transect waypoints
wpt.a <- st_as_sf(tx.a, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))
wpt.c <- st_as_sf(tx.c, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))
wpt.s <- st_as_sf(tx.s, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))
wpt.m <- st_as_sf(tx.m, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))

wpt.t <- st_as_sf(tx.t, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))

# Create UCTD waypoints
wpt.u <- st_as_sf(uctd, coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))

# Create CalCOFI station waypoints
wpt.80 <- tx.80 %>% 
  st_as_sf(coords = c("long","lat"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))

# Convert points to lines
tx.a <- points2line(data = tx.a, "Longitude", "Latitude", "Transect", "Waypoint") %>%
  st_as_sf()
tx.c <- points2line(data = tx.c, "Longitude", "Latitude", "Transect", "Waypoint") %>%
  st_as_sf()
tx.s <- points2line(data = tx.s, "Longitude", "Latitude", "Transect", "Waypoint") %>%
  st_as_sf()
tx.m <- points2line(data = tx.m, "Longitude", "Latitude", "Transect", "Waypoint") %>%
  st_as_sf()
tx.t <- points2line(data = tx.t, "Longitude", "Latitude") %>%
  st_as_sf()
tx.80 <- points2line(data = tx.80, "long", "lat") %>%
  st_as_sf()

# Create mapview waypoints and transects
wpt.mapview <- st_as_sf(filter(wpt, Type != "Extra"), coords = c("Longitude","Latitude"), crs = 4326) %>% 
  mutate(long = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat  = map_dbl(geometry, ~st_centroid(.x)[[2]]))

tx.mapview <- tx.a %>% 
  rbind(tx.c) %>% 
  rbind(tx.s) %>% 
  rbind(tx.m) %>% 
  rbind(tx.t)
```

`r format(Sys.time(), "%d %B %Y")`

# Interative map viewer

Planned compulsory (blue), adaptive (red), marine mammal (green), Saildrone (orange), and UCTD (gray) stations/transects. You may pan (click-and-drag or use arrow keys), zoom (using the +/- key, your mouse wheel, or the controls on the map), and click objects to view more details about map features. Different base maps may be chosen and layers may be toggled on/off using the layer control feature in the upper left corner. Additional waypoint information may be found in the tables below the map.

```{r Leaflet,eval=F}
# https://bhaskarvk.github.io/leaflet-talk-rstudioconf-2017/RstudioConf2017.html#18

# Configure palette for MPAs
factpal <- colorFactor(topo.colors(10), ca_mpas$MPA)

# Create leaflet map
leaflet() %>% 
  addProviderTiles(leaflet.tile) %>% 
  addPolygons(data = ca_waters, weight = 2, color = "black", fillColor = "transparent") %>% 
  addPolygons(data = ca_mpas, color = "black", weight = 2, fillColor =  ~factpal(MPA), fillOpacity = 1,
              label = ~htmlEscape(MPA)) %>%
  addPolylines(data = tx.c, color = "blue", weight = 2) %>% 
  addPolylines(data = tx.a, color = "red", weight = 2) %>% 
  addPolylines(data = tx.m, color = "green", weight = 2) %>% 
  addPolylines(data = tx.s, color = "orange", weight = 4) %>% 
  addCircleMarkers(data = wpt.a, radius = 3, color = "red", stroke = FALSE, fillOpacity = 0.75,
                   label = ~htmlEscape(paste("Adaptive", Waypoint, lat, "N", long, "W"))) %>% 
  addCircleMarkers(data = wpt.c, radius = 3, color = "blue", stroke = FALSE, fillOpacity = 0.75,
                   label = ~htmlEscape(paste("Compulsory", Waypoint, lat, "N", long, "W"))) %>% 
  addCircleMarkers(data = wpt.s, radius = 3, color = "orange", stroke = FALSE, fillOpacity = 0.75,
                   label = ~htmlEscape(paste("Saildrone", Waypoint, lat, "N", long, "W"))) %>% 
  addCircleMarkers(data = wpt.m, radius = 3, color = "green", stroke = FALSE, fillOpacity = 0.75,
                   label = ~htmlEscape(paste("Marine mammal", Waypoint, lat, "N", long, "W"))) %>% 
  addCircleMarkers(data = wpt.u, radius = 2, color = "black", fill = "transparent", stroke = TRUE,
                   label = ~htmlEscape(paste(Name, lat, "N", long, "W"))) %>% 
  addMouseCoordinates(style = "basic")
```

```{r Mapview, out.width='100%'}
# Select tiles to use for Leaflet map
# Some good options include CartoDB.Positron, Stamen.Terrain, Esri.WorldImagery, and Esri.OceanBasemap
# View all here: http://leaflet-extras.github.io/leaflet-providers/preview/index.html

# Configure mapview options
mapviewOptions(basemaps = c("Esri.OceanBasemap","Esri.WorldImagery","CartoDB.Positron"))

# Create mapview map
mapview(ca_waters, alpha = 0.7, alpha.region = 0.1, layer.name = "CA State Waters") +
  mapview(ca_mpas, zcol = "Type", layer.name = "CA MPAs") +
  mapview(tx.80, color = "black",  alpha = 0.5, layer.name = "CalCOFI", col.regions = "black") +
  mapview(wpt.80,color = "black",  cex = 4,     layer.name = "CalCOFI") +
  mapview(tx.c,  color = "blue",   alpha = 0.5, layer.name = "Compulsory Lines", col.regions = "blue") +
  mapview(wpt.c, color = "blue",   cex = 4,     layer.name = "Compulsory Lines") +
  mapview(tx.a,  color = "red",    alpha = 0.5, layer.name = "Adaptive Lines") +
  mapview(wpt.a, color = "red",    cex = 4,     layer.name = "Adaptive Lines", col.regions = "red")  +
  mapview(tx.m,  color = "green",  alpha = 0.5, layer.name = "Mammal Lines") +
  mapview(wpt.m, color = "green",  cex = 4,     layer.name = "Mammal Lines", col.regions = "green") +  
  mapview(tx.s,  color = "orange", alpha = 0.5, layer.name = "Saildrone Lines") +
  mapview(wpt.s, color = "orange", cex = 4,     layer.name = "Saildrone Lines", col.regions = "orange") +  
  mapview(tx.t,  color = "yellow", alpha = 0.5, layer.name = "Transit Lines") +
  mapview(wpt.t, color = "yellow", cex = 4,     layer.name = "Transit Lines") + 
  mapview(wpt.u, color = "black",  cex = 2,     layer.name = "UCTD Stations", col.regions = "black")
```

# Compulsory waypoints

```{r}
# Print cluster check table
filter(wpt, Type == "Compulsory") %>% 
  kable(format = knitr.format,booktabs = T, escape = F,
        align = c("c")) %>% 
  kable_styling(bootstrap_options = c("striped","hover","condensed"),full_width = F) %>%
  row_spec(0, align = c("c")) %>% 
  scroll_box(height = "500px")
```

# Adaptive waypoints

```{r}
# Print cluster check table
filter(wpt, Type == "Adaptive") %>% 
  kable(format = knitr.format,booktabs = T, escape = F,
        align = c("c")) %>% 
  kable_styling(bootstrap_options = c("striped","hover","condensed"),full_width = F) %>%
  row_spec(0, align = c("c")) %>% 
  scroll_box(height = "500px")
```

# Saildrone waypoints

```{r}
# Print cluster check table
filter(wpt, Type == "Saildrone") %>% 
  kable(format = knitr.format,booktabs = T, escape = F,
        align = c("c")) %>% 
  kable_styling(bootstrap_options = c("striped","hover","condensed"),full_width = F) %>%
  row_spec(0, align = c("c")) %>% 
  scroll_box(height = "500px")
```

# Marine Mammal waypoints

```{r}
# Print cluster check table
filter(wpt, Type == "Mammal") %>% 
  kable(format = knitr.format,booktabs = T, escape = F,
        align = c("c")) %>% 
  kable_styling(bootstrap_options = c("striped","hover","condensed"),full_width = F) %>%
  row_spec(0, align = c("c")) %>% 
  scroll_box(height = "500px")
```

# UCTD waypoints

```{r}
# Print cluster check table
uctd %>% 
  kable(format = knitr.format,booktabs = T, escape = F,
        align = c("c")) %>% 
  kable_styling(bootstrap_options = c("striped","hover","condensed"),full_width = F) %>%
  row_spec(0, align = c("c")) %>% 
  scroll_box(height = "500px")
```

```{r AddLogo, fig.align='center',out.width='100%'}
include_graphics(here("Images/ast_logo.png"))
```